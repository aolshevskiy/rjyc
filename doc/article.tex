\documentclass{article}
\usepackage[koi8-ru]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{hyperref}
\usepackage{listings}
\lstset{language=Python,
  breaklines=true,
  breakatwhitespace=false}
\author{Artyom Olshevskiy}
\title{Jython-консоль вашего приложения}
\begin{document}
Расскажу вам как я использую интерактивную консоль Jython для ускорения
разработки Bean'ов в поддерживаемом мной приложении.
\section{Суть вопроса}
Каждый кто хоть раз сталкивался с долго разрабатывающимися
Java-приложениями, знает, что многие из них очень медленно собираются
и стартуют. Не будем обсуждать почему так получается. Это тема
отдельной статьи. 

По долгу службы пришлось поддерживаю очень древнее приложение с
громадной кодовой базой. Хуже всего то, что оно собирается оно от
минуты до семи и ещё минуты три стартует. Опять же каждому
программисту не сложно представить себе какой ад написать энное
количество кода, а затем ловить NullPointerException'ы от внешних
сервисов с таким длинным циклом Implement->Compile->Start
Deploy->Wait->Smoke->Wait->Test. 

Возможен также другой вариант. Есть энное количество кода в
классе, который нужно адаптировать под выполнение задачи, близкой уже
им выполняемой. А теперь представьте, что этот класс реализован в
рамках Java 1.4. Он не работает с Generic'ами, потому что они были
добавлены только в Java 1.5. Кроме того программисты, ранее
занимавшиеся поддержкой системы, этим активно пользуются и суют в коллекции
возвращаемые методами других классов, что не попадя вплоть до анонимных
реализаций java.lang.Object.

Поев кактус пару дней я почувствовал, что начинаю сходить с ума от
того, что пишу \emph{пять-двадцать} строк работающего кода в день.

Способом ускорения разработки в таких варварских условиях
я усмотрел только вкрутить в приложение интерпретатор какого-либо
динамического языка для быстрого прототипирования уязвимого к таким
условиям кода сначала на нём, а потом реализации алгоритма на
Java. Конечно же в рамках решение нужна была ещё и интерактивная
консоль этого языка. Какая же без этого динамика? Консоль хотелось в
не в апплете из-за того, что апплеты очень плохо работают(скажем так,
они просто не работают) во FreeBSD, к которой я очень уж привык в
последнее время.

\section{Поиск существующих решений}
Как приверженец мнения, что изобретать ``вило''-сипеды(потому как
часто от них остаются только вилы :) ) не тру, решил на выходных
копать в сторону уже существующих решений этого вопроса. Очень
хотелось Python. Но перед тем как вернутся к первому выбору, успел
посмотреть в сторону:
\begin{itemize}
\item Beanshell - отброшен по причине убогости телнет-консоли,
  поставляемой из коробки вместе с интерпретатором. Апплет не подходит.
\item JRuby - отброшен по причине не того, что я обнаружил, что успел
  благополучно забыть этот язык с тех пор, как игрался с Rails во
  времена первой вспышки его популярности. Быстрое гугление не дало
  результатов кроме каких-то Corba-монстров. Испугался и закрыл :)
\item Groovy 

  Что-то похожее на то, что хотел
  \href{http://confluence.sakaiproject.org/display/SGS/Home}{нашёл у
    Sakai}. Реализовано в качестве Spring Bean'а, а у нас свой
  Dependecy Injection-фрэймворк с блэкджеком и шлюхами. Не попробовал.
\end{itemize}

\subsection{Jython}
Python-программистам хорошо известна одна из его концепций ``batteries
included'', что означает много разных вкусных библиотек даже в
стандартной поставке. Только у Java свои батарейки. Реализация Python
для JVM просто эталонная, а вот библиотеки пока портированы не
полностью(например setuptools начал устанавливаться в Jython-окружении
совсем недавно), так что у меня не получилось завести родные
Python-решения.

Попробовал \href{http://rpyc.wikidot.com/}{RPyC} с разными версиями
Jython(ночь прошла незаметно :) ). Почитал про
\href{http://twistedmatrix.com/documents/8.1.0/api/twisted.manhole.html}{Twisted
  Manhole}. Решил не сливать исходники тестовой ветки интеграции с
Jython, потому как была опасность начать фиксить Twisted для Jython и
стать после этого холостяком.

Собрал
\href{JythonShellServer}{http://github.com/EnigmaCurry/jython-shell-server/tree}
и понял: нет readline, нет счастья. Telnet не поддерживает readline,
если разработчик не реализовал эту функциональность на серверной
стороне. Представьте, что написали строку длиной в символов в 80 и
вспомнили, что первый объект называется по другому. Конечно можно
торкать мышкой в консоль, но хотелось родной похожей на bash-среды.

\section{Моя реализация}
\subsection{Сервер}
За пять минут выбрал XMLRPC в качестве интерфейса сервера. За
следующих пять минут не передумал. За следующих 20 минут реализовал.

Код сервера на Jython:
\lstinputlisting{server.py}
\subsection{Клиент}
В качестве базового интерфейса был выбран Cmd, который из коробки поддерживает readline, что нам и нужно.

Код сервера на этот раз на Python(похоже Cmd в Jython не поддерживает readline):
\lstinputlisting{client.py}
\subsection{Java-обёртка для сервера}
Простой Bean для запуска нашего сервера. Проще просто некуда.
\lstinputlisting{Server.java}
\section{Использование}
Предствьте себе гипотетический сервлет, который выводит список ссылок
из своего поля.

\lstinputlisting{Hello.java}

Вот, что нам отвечает вебсервер:
\begin{verbatim}
siasia@host ~ % wget http://localhost:8080 -O - 2>/dev/null
<a href="http://python.org">Python</a>
<a href="http://java.net">Java</a>
\end{verbatim}

Теперь внедрим в него нашу консоль.

\lstinputlisting{ConsoledHello.java}

И подключимся к ней:
\begin{verbatim}
siasia@epbyminw2121 ~ % python client.py localhost 8081
>>> this
examples.Hello@13ebc5c
>>> this.links
{Python=http://python.org, Java=http://java.net}
>>> this.links['Scala'] = 'http://scala-lang.org'
>>> this.links
{Scala=http://scala-lang.org, Python=http://python.org, Java=http://java.net}
\end{verbatim}

Проверим результат:
\begin{verbatim}
siasia@epbyminw2121 ~ % wget http://localhost:8080 -O - 2>/dev/null
<a href="http://scala-lang.org">Scala</a>
<a href="http://python.org">Python</a>
<a href="http://java.net">Java</a>
\end{verbatim}

\section{Maven}
\begin{enumerate}
\item Добавьте репозиторий в свой pom.xml:
\begin{verbatim}
<repository>
  <id>Rjyc Repository</id>
  <url>http://siasia.github.com/maven2</url>
</repository>
\end{verbatim}
\item Добавьте зависимость от rjyc:
\begin{verbatim}
<dependency>
  <groupId>org.python</groupId>
  <artifactId>rjyc</artifactId>
  <version>1.0-SNAPSHOT</version>
</dependency>
\end{verbatim}
\item Импортируйте сервер в своём коде:
\begin{verbatim}
import net.rjyc.Server;
\end{verbatim}
\item Запустите его как описано выше.
\item Скачайте клиент \url{http://github.com/siasia/rjyc/raw/master/client.py}.
\item python client.py host port
\item PROFIT!!!
\end{enumerate}

Надеюсь, эта статья сделает ещё кого-то немного счастливее :)

Форкайте меня на github \url{http://github.com/siasia}.
\end{document}
