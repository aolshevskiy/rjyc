\documentclass{article}
\usepackage[koi8-ru]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{hyperref}
\author{Artyom Olshevskiy}
\title{Jython-консоль вашего приложения}
\begin{document}
Расскажу вам как я использую интерактивную консоль Jython для ускорения
разработки Bean'ов в поддерживаемом мной приложении.
\section{Суть вопроса}
Каждый кто хоть раз сталкивался с долго разрабатывающимися
Java-приложениями, знает, что многие из них очень медленно собираются
и стартуют. Не будем обсуждать почему так получается. Это тема
отдельной статьи. 

По долгу службы пришлось поддерживаю очень древнее приложение с
громадной кодовой базой. Хуже всего то, что оно собирается оно от
минуты до семи и ещё минуты три стартует. Опять же каждому
программисту не сложно представить себе какой ад написать энное
количество кода, а затем ловить NullPointerException'ы от внешних
сервисов с таким длинным циклом Implement->Compile->Start
Deploy->Wait->Smoke->Wait->Test. 

Возможен также другой вариант. Есть энное количество кода в
классе, который нужно адаптировать под выполнение задачи, близкой уже
им выполняемой. А теперь представьте, что этот класс реализован в
рамках Java 1.4. Он не работает с Generic'ами, потому что они были
добавлены только в Java 1.5. Кроме того программисты, ранее
занимавшиеся поддержкой системы, этим активно пользуются и суют в коллекции
возвращаемые методами других классов, что не попадя вплоть до анонимных
реализаций java.lang.Object.

Поев кактус пару дней я почувствовал, что начинаю сходить с ума от
того, что пишу \emph{пять-двадцать} строк работающего кода в день.

Способом ускорения разработки в таких варварских условиях
я усмотрел только вкрутить в приложение интерпретатор какого-либо
динамического языка для быстрого прототипирования уязвимого к таким
условиям кода сначала на нём, а потом реализации алгоритма на
Java. Конечно же в рамках решение нужна была ещё и интерактивная
консоль этого языка. Какая же без этого динамика? Консоль хотелось в
не в апплете из-за того, что апплеты очень плохо работают(скажем так,
они просто не работают) во FreeBSD, к которой я очень уж привык в
последнее время.

\section{Поиск существующих решений}
Как приверженец мнения, что изобретать ``вило''-сипеды(потому как
часто от них остаются только вилы :) ) не тру, решил на выходных
копать в сторону уже существующих решений этого вопроса. Очень
хотелось Python. Но перед тем как вернутся к первому выбору, успел
посмотреть в сторону:
\begin{itemize}
\item Beanshell - отброшен по причине убогости телнет-консоли,
  поставляемой из коробки вместе с интерпретатором. Апплет не подходит.
\item JRuby - отброшен по причине не того, что я обнаружил, что успел
  благополучно забыть этот язык с тех пор, как игрался с Rails во
  времена первой вспышки его популярности. Быстрое гугление не дало
  результатов кроме каких-то Corba-монстров. Испугался и закрыл :)
\item Groovy 

  Что-то похожее на то, что хотел
  \href{http://confluence.sakaiproject.org/display/SGS/Home}{нашёл у
    Sakai}. Реализовано в качестве Spring Bean'а, а у нас свой
  Dependecy Injection-фрэймворк с блэкджеком и шлюхами. Не попробовал.
\end{itemize}

\subsection{Jython}
Python-программистам хорошо известна одна из его концепций ``batteries
included'', что означает много разных вкусных библиотек даже в
стандартной поставке. Только у Java свои батарейки. Реализация Python
для JVM просто эталонная, а вот библиотеки пока портированы не
полностью(например setuptools начал устанавливаться в Jython-окружении
совсем недавно), так что у меня не получилось завести родные
Python-решения.

Попробовал \href{http://rpyc.wikidot.com/}{RPyC} с разными версиями
Jython(ночь прошла незаметно :) ). Почитал про
\href{http://twistedmatrix.com/documents/8.1.0/api/twisted.manhole.html}{Twisted
  Manhole}. Решил не сливать исходники тестовой ветки интеграции с
Jython, потому как была опасность начать фиксить Twisted для Jython и
стать после этого холостяком.

Собрал
\href{JythonShellServer}{http://github.com/EnigmaCurry/jython-shell-server/tree}
и понял: нет readline, нет счастья. Telnet не поддерживает readline,
если разработчик не реализовал эту функциональность на серверной
стороне. Представьте, что написали строку длиной в символов в 80 и
вспомнили, что первый объект называется по другому. Конечно можно
торкать мышкой в консоль, но хотелось родной похожей на bash-среды.

\section{Моя реализация}
\subsection{Server}
За пять минут выбрал 
\end{document}